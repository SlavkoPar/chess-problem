{"version":3,"file":"static/js/505.e03d6e26.chunk.js","mappings":"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","sources":["helpers.ts","Thread.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const Board = [\r\n    ['a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8'],\r\n    ['a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7'],\r\n    ['a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6'],\r\n    ['a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5'],\r\n    ['a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4'],\r\n    ['a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3'],\r\n    ['a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2'],\r\n    ['a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1']\r\n]\r\n\r\nexport const columns = \"abcdefgh\";\r\n\r\nexport const emptyLines = (pieces: { i: number, j: number }[]): boolean => {\r\n    let a = pieces.map(square => square.i).sort();\r\n    for (let x = 0; x < a.length - 1; x++) {\r\n        if (a[x + 1] - a[x] > 3) {   // a2-a7 means 3 empty lines\r\n            return true;\r\n        }\r\n    }\r\n    a = pieces.map(square => square.j).sort();\r\n    for (let x = 0; x < a.length - 1; x++) {\r\n        if (a[x + 1] - a[x] > 3) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nlet iMinW = 9; let iMaxW = -1;\r\nlet jMinW = 9; let jMaxW = -1;\r\nexport const calcWhitePiecesSquare = (whitePieces: { i: number, j: number }[]): void => {\r\n    iMinW = 9; iMaxW = -1;\r\n    jMinW = 9; jMaxW = -1;\r\n    for (let square of whitePieces) {\r\n        const { i, j } = square;\r\n        if (i < iMinW) iMinW = i;\r\n        if (i > iMaxW) iMaxW = i;\r\n        if (j < jMinW) jMinW = j;\r\n        if (j > jMaxW) jMaxW = j;\r\n    }\r\n}\r\n\r\nexport const anyWhitePieceInsideOfBlackPiecesSquare = (blackPieces: { i: number, j: number }[]): boolean => {\r\n    for (const square of blackPieces) {\r\n        const { i, j } = square;\r\n        //console.log('i>', iMinW, i, iMaxW, i >= iMinW && i <= iMaxW)\r\n        //console.log('j>', jMinW, j, jMaxW, j >= jMinW && j <= jMaxW);\r\n        if (i >= iMinW && i <= iMaxW && j >= jMinW && j <= jMaxW) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n// between white pieces and black king\r\nexport const twoEmptyLinesWhitesBlacks = (\r\n    whitePieces: { i: number, j: number }[],\r\n    blackPieces: { i: number, j: number }[]): boolean => {\r\n    const whiteMaxI = Math.max(...whitePieces.map(square => square.i));\r\n    const blackMinI = Math.min(...blackPieces.map(square => square.i));\r\n    if (Math.abs(whiteMaxI - blackMinI) > 1)\r\n        return true;\r\n    const whiteMaxJ = Math.max(...whitePieces.map(square => square.j));\r\n    const blackMinJ = Math.min(...blackPieces.map(square => square.j));\r\n    if (Math.abs(whiteMaxJ - blackMinJ) > 1)\r\n        return true;\r\n    return false;\r\n}\r\n\r\nconst diagonal1: string[][] = [\r\n    ['a1', 'b2', 'c3', 'd4', 'e5', 'f6', 'g7', 'h8'],\r\n    ['a2', 'b3', 'c4', 'd5', 'e6', 'f7', 'g8'],\r\n    ['a3', 'b4', 'c5', 'd6', 'e7', 'f8'],\r\n    ['a4', 'b5', 'c6', 'd7', 'e8'],\r\n    ['a5', 'b6', 'c7', 'd8'],\r\n    ['a6', 'b7', 'c8'],\r\n    ['a7', 'b8'],\r\n    ['b1', 'c2', 'd3', 'e4', 'f5', 'g6', 'h7'],\r\n    ['c1', 'd2', 'e3', 'f4', 'g5', 'h6'],\r\n    ['d1', 'e2', 'f3', 'g4', 'h5'],\r\n    ['e1', 'f2', 'g3', 'h4'],\r\n    ['f1', 'g2', 'h3'],\r\n    ['g1', 'h2']\r\n]\r\n\r\nconst diagonal2: string[][] = [\r\n    ['h1', 'g2', 'f3', 'e4', 'd5', 'c6', 'b7', 'a8'],\r\n    ['h2', 'g3', 'f4', 'e5', 'd6', 'c7', 'b8'],\r\n    ['h3', 'g4', 'f5', 'e6', 'd7', 'c8'],\r\n    ['h4', 'g5', 'f6', 'e7', 'd8'],\r\n    ['h5', 'g6', 'f7', 'e8'],\r\n    ['h6', 'g7', 'f8'],\r\n    ['h7', 'g8'],\r\n    ['g1', 'f2', 'e3', 'd4', 'c5', 'b6', 'a7'],\r\n    ['f1', 'e2', 'd3', 'c4', 'b5', 'a6'],\r\n    ['e1', 'd2', 'c3', 'b4', 'a5'],\r\n    ['d1', 'c2', 'b3', 'a4'],\r\n    ['c1', 'b2', 'a3'],\r\n    ['b1', 'a2']\r\n]\r\n\r\nconst diagonal: Record<string, string[]> = {};\r\nfor (const row of ['1', '2', '3', '4', '5', '6', '7', '8']) {\r\n    for (const col of ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']) {\r\n        const square = col + row;\r\n        diagonal[square] = [];\r\n        for (const line of diagonal1) {\r\n            if (line.includes(square))\r\n                diagonal[square].push(...line.filter(x => x !== square))\r\n        }\r\n        for (const line of diagonal2) {\r\n            if (line.includes(square))\r\n                diagonal[square].push(...line.filter(x => x !== square))\r\n        }\r\n    }\r\n}\r\nexport const isOnDiagonal = (square1: string, square2: string): boolean => diagonal[square1].includes(square2);\r\n\r\nexport const applyNightFirewall = (board: [({ type: string, color: string, square: string } | null)[]], queenOrBishop: string): boolean => {\r\n    // 1.Pattern: Queen Night firewall\r\n    let squareQ = null;\r\n    let squareN = null;\r\n    for (let i = 0; i < 8 && (!squareQ || !squareN); i++) {\r\n        const row = board[i];\r\n        for (let j = 0; j < 8 && (!squareQ || !squareN); j++) {\r\n            if (row[j]) {\r\n                const { type, color, square } = row[j]!;\r\n                if (type === queenOrBishop && color === 'w') {\r\n                    squareQ = square;\r\n                }\r\n                else if (type === 'n' && color === 'w') {\r\n                    squareN = square;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!squareN || !squareQ) {\r\n        return false; // may Q or N has been taken in the black move\r\n    }\r\n    const jQ = parseInt(squareQ!.charAt(1));\r\n    const iQ = columns.indexOf(squareQ!.charAt(0));\r\n    const jN = parseInt(squareN!.charAt(1));\r\n    const iN = columns.indexOf(squareN!.charAt(0));\r\n    let bRet = (iQ === iN && (Math.abs(jQ - jN) === 2 || Math.abs(jQ - jN) === 4)) ||\r\n        (jQ === jN && (Math.abs(iQ - iN) === 2 || Math.abs(iQ - iN) === 4));\r\n    if (!bRet) {\r\n        bRet = isOnDiagonal(squareQ, squareN);\r\n    }\r\n    return bRet;\r\n}\r\n\r\n\r\nexport const applyRookKing = (board: [({ type: string, color: string, square: string } | null)[]]): boolean => {\r\n    // 3. Pattern: Rook King\r\n    let whiteKingSquare = null;\r\n    let blackKingSquare = null;\r\n    const rooks: string[] = [];\r\n    for (let i = 0; i < 8; i++) {\r\n        const row = board[i];\r\n        for (let j = 0; j < 8 && (!whiteKingSquare || !blackKingSquare); j++) {\r\n            if (row[j]) {\r\n                const { type, color, square } = row[j]!;\r\n                if (type === 'k') {\r\n                    if (color === 'w')\r\n                        whiteKingSquare = square;\r\n                    else\r\n                        blackKingSquare = square;\r\n                }\r\n                else if (type === 'r' && color === 'w') {\r\n                    rooks.push(square)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const iWK = parseInt(whiteKingSquare!.charAt(1));\r\n    const jWK = columns.indexOf(whiteKingSquare!.charAt(0));\r\n\r\n    const iBK = parseInt(blackKingSquare!.charAt(1));\r\n    const jBK = columns.indexOf(blackKingSquare!.charAt(0));\r\n\r\n    if (iWK === iBK && Math.abs(jWK - jBK) === 2) {\r\n        for (const rook of rooks) {\r\n            const jRook = columns.indexOf(rook.charAt(0));\r\n            if (jRook === jBK) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    else if (jWK === jBK && Math.abs(iWK - iBK) === 2) {\r\n        for (const rook of rooks) {\r\n            const iRook = parseInt(rook.charAt(1));\r\n            if (iRook === iBK) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport const markWhiteSquareBishops = (\r\n    pieces: string[],\r\n    board: [({ type: string, color: string, square: string } | null)[]],\r\n    squareColor: (square: string) => string\r\n) => {\r\n    const whiteSquareBishops: boolean[] = [];\r\n\r\n    const taken: boolean[][] = [];\r\n    for (let i = 0; i < 8; i++) {\r\n        taken[i] = [];\r\n        for (let j = 0; j < 8; j++)\r\n            taken[i][j] = false;\r\n    }\r\n\r\n    for (const piece of pieces) {\r\n        const pieceColor = ['K', 'Q', 'R', 'B', 'N', 'P'].includes(piece) ? 'w' : 'b';\r\n        const pieceType = piece.toLowerCase();\r\n        let found = false;\r\n        for (let i = 0; i < 8 && !found; i++) {\r\n            const row = board[i];\r\n            for (let j = 0; j < 8 && !found; j++) {\r\n                const p = row[j];\r\n                if (p) {\r\n                    const { type, color, square } = p!;\r\n                    if (type === pieceType && color === pieceColor) {\r\n                        const isWhiteSquare = type === 'b' && !taken[i][j] && squareColor(square) === 'light';\r\n                        taken[i][j] = true;\r\n                        whiteSquareBishops.push(isWhiteSquare);\r\n                        found = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return whiteSquareBishops;\r\n}\r\n\r\nconst arroundWhiteKing: Record<string, string[]> = {};\r\n\r\nconst arrounds = (i: number, j: number): string[] => {\r\n    let arr: string[] = []\r\n    for (let r = i - 1; r <= i + 1; r++) {\r\n        if (r < 1 || r > 8) continue;\r\n        for (let c = j - 1; c <= j + 1; c++) {\r\n            if (c < 0 || r > 7 || (r === i && c === j)) continue;\r\n            arr.push(columns[c] + r);\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nfor (let i = 1; i <= 8; i++) {\r\n    for (let j = 0; j < 8; j++) {\r\n        arroundWhiteKing[columns[j] + i] = arrounds(i, j);\r\n    }\r\n}\r\n\r\nexport const touchingWhiteKing = (whiteKingSquare: string, blackPieceSquare: string): boolean => {\r\n    return arroundWhiteKing[whiteKingSquare].includes(blackPieceSquare);\r\n}\r\n\r\nexport { };\r\n","\r\n/* eslint-disable no-restricted-globals */\r\nimport { FindProblem, TProblem } from \"./App\";\r\nimport {\r\n    Board,\r\n    markWhiteSquareBishops,\r\n    calcWhitePiecesSquare,\r\n    anyWhitePieceInsideOfBlackPiecesSquare,\r\n    emptyLines,\r\n    applyNightFirewall,\r\n    columns,\r\n    touchingWhiteKing,\r\n    applyRookKing\r\n} from './helpers'\r\nconst { Chess } = require(\"chess.js\");\r\n\r\nconst regexCheck = new RegExp('[#+]$');\r\nconst regexCheckmate = new RegExp('#$');\r\n\r\nconst position: string[] = [];\r\n\r\nself.onmessage = (e: MessageEvent<string>) => {\r\n    const findProblem = JSON.parse(e.data) as FindProblem;\r\n    const { action, pieces, indexOfBlack, lookingForFen, fromSquare, toSquare, testFen } = findProblem;\r\n    const whiteSquareBishops: boolean[] = [];\r\n\r\n    const chess = testFen ? new Chess(testFen) : new Chess(lookingForFen);\r\n    if (!testFen) {\r\n\r\n        const board = chess.board();\r\n        const whiteBishops = markWhiteSquareBishops(pieces, board, (square: string) => chess.squareColor(square));\r\n        whiteSquareBishops.push(...whiteBishops);\r\n\r\n        chess.clear();\r\n    }\r\n\r\n    // patterns\r\n    let nPatterns = 0;\r\n    const applyQueenNightFirewall = pieces.includes('Q') && pieces.includes('N');\r\n    if (applyQueenNightFirewall)\r\n        nPatterns++;\r\n\r\n    const applyBishopNightFirewall = pieces.includes('B') && pieces.includes('N');\r\n    if (applyBishopNightFirewall)\r\n        nPatterns++;\r\n\r\n    /////////////////////////////////////\r\n    // TODO Queen the same as Rook ?????\r\n    const applyRook = pieces.includes('R');\r\n    if (applyRook)\r\n        nPatterns++;\r\n\r\n    /*\r\n    let ind = 0;\r\n    let j = 0;\r\n    //const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\r\n    for (; j < Board.length; j++) {\r\n        ind = Board[j].indexOf(fromSquare);\r\n        if (ind !== -1) {\r\n            break;\r\n        }\r\n    }\r\n    const ind2 = ind + nSquares;\r\n    const board: string[] = [];\r\n    for (let i = 0; i < nSquares - j; i++) {\r\n        board.push(...Board[j + i].slice(ind, ind2));\r\n    }\r\n    */\r\n    const board: string[] = [];\r\n    for (const row of Board) {\r\n        board.push(...row);\r\n    }\r\n\r\n    const kingBoard: string[] = [];\r\n    let radi = false;\r\n    for (const square of board) {\r\n        if (square === fromSquare) {\r\n            radi = true;\r\n        }\r\n        else if (square === toSquare) {\r\n            kingBoard.push(square);\r\n            radi = false;\r\n        }\r\n        if (radi)\r\n            kingBoard.push(square);\r\n    }\r\n\r\n\r\n    const isPattern = (board: [({ type: string, color: string, square: string } | null)[]]): boolean => {\r\n        // 1. Pattern: Queen Night firewall\r\n        if (applyQueenNightFirewall) {\r\n            if (applyNightFirewall(board, 'q'))\r\n                return true;\r\n        }\r\n        // 2. Pattern: Bishop Night firewall\r\n        if (applyBishopNightFirewall) {\r\n            if (applyNightFirewall(board, 'b'))\r\n                return true;\r\n        }\r\n        // 3. Pattern: Rook King pattern\r\n        if (applyRook) {\r\n            if (applyRookKing(board))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    const checkmateIn2 = (): string | null => {\r\n        const whiteMoves1 = chess.moves();\r\n        // white first move must not be the check or checkmate or eat the black piece\r\n        const moves1 = whiteMoves1.filter((m: string) => !regexCheck.test(m) && !m.includes('x'));\r\n        let nMates1 = 0;\r\n        let firstMove: string | null = null;\r\n        let oneOfTheCheckmatesIsPattern = false;\r\n        // one of the moves should be check\r\n        for (const white1 of moves1) {\r\n            // white1 \r\n            chess.move(white1);\r\n            // black 1\r\n            const blackMoves = chess.moves();\r\n            let nMates2 = 0;\r\n            oneOfTheCheckmatesIsPattern = false;\r\n            for (const black of blackMoves) {\r\n                chess.move(black);\r\n                // white 2\r\n                const white2Moves = chess.moves();\r\n                const whiteMates = white2Moves.filter((m: string) => regexCheckmate.test(m) &&\r\n                    !(m.includes('=Q') || m.includes('=R')));\r\n                nMates2 = whiteMates.length;\r\n                if (nMates2 > 0 && nPatterns > 0) {\r\n                    for (const white2 of whiteMates) {\r\n                        chess.move(white2);\r\n                        // is there any of checkmates a pattern?\r\n                        if (isPattern(chess.board())) {\r\n                            oneOfTheCheckmatesIsPattern = true;\r\n                        }\r\n                        chess.undo();\r\n                        if (oneOfTheCheckmatesIsPattern)\r\n                            break;\r\n                    }\r\n                }\r\n                chess.undo();\r\n                if (nMates2 === 0)\r\n                    break; // second move is not checkmate or there are more than 1 checkmate\r\n            }\r\n            if (nMates2 > 0 && (nPatterns === 0 || oneOfTheCheckmatesIsPattern)) {\r\n                if (testFen)\r\n                    console.log('checkmate at second move', white1)\r\n                nMates1++;\r\n                firstMove = white1;\r\n                console.log('firstMove:', firstMove)\r\n            }\r\n            chess.undo();\r\n        }\r\n        if (testFen)\r\n            console.log(nMates1 === 1 ? 'Position is problem' : 'Position is not problem')\r\n        return nMates1 === 1 ? firstMove : null;\r\n    }\r\n\r\n    const whitePieces: { i: number, j: number }[] = [];\r\n    const blackPieces: { i: number, j: number }[] = [];\r\n\r\n    let goToNextMoveOfTheLastWhitePiece = false;\r\n\r\n    let lastCheckmate: string | null = null;\r\n\r\n    function getPosition(pieces: string[], index: number): void {\r\n        const piece = pieces.shift();\r\n        const c = piece!.charAt(0);\r\n        const type = c.toLowerCase();\r\n        const pieceColor = /[RNBKQP]/.test(c) ? 'w' : 'b';\r\n        const isBlack = index >= indexOfBlack; // pieceColor === 'b';\r\n        const whiteKing = c === 'K';\r\n        const blackKing = c === 'k';\r\n        const isBishop = type === 'b';\r\n        const whiteSquareBishop = isBishop && whiteSquareBishops[index];\r\n        // console.log(piece)\r\n        const boardMy = whiteKing ? kingBoard : board;\r\n        for (const square of boardMy) {\r\n            if (goToNextMoveOfTheLastWhitePiece) {\r\n                if (pieceColor === 'w') {\r\n                    goToNextMoveOfTheLastWhitePiece = false;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            if (!position.includes(square) && !((type === 'p' && (square.includes('8') || square.includes('1'))))) {\r\n                const piecePlaced = chess.put({ type, color: pieceColor }, square);\r\n                // white 'K' is at position[0]\r\n                let invalidPos = false;\r\n                if ((isBishop && ((whiteSquareBishop && chess.squareColor(square) === 'dark') ||\r\n                    (!whiteSquareBishop && chess.squareColor(square) === 'light')))\r\n                ) {\r\n                    invalidPos = true;\r\n                }\r\n                if (!invalidPos && isBlack) {\r\n                    console.assert(pieceColor === 'b', 'Should be black piece')\r\n                    if (blackKing) {\r\n                        if (touchingWhiteKing(position[0], square)) {\r\n                            invalidPos = true;\r\n                        }\r\n                        else {\r\n                            if (chess.isAttacked(square, 'w'))\r\n                                invalidPos = true;\r\n                        }\r\n                    }\r\n                    else if (chess.isCheck()) {\r\n                        invalidPos = true;\r\n                        if (['q', 'r', 'b'].includes(type) && !touchingWhiteKing(position[0], square)) {\r\n                            invalidPos = false;\r\n                        }\r\n                    }\r\n                }\r\n                if (invalidPos) {\r\n                    const z = chess.remove(square);\r\n                }\r\n                else if (piecePlaced) {\r\n                        let whiteEmptyLines = false;\r\n                        let blackEmptyLines = false;\r\n                        //let whiteHasCheck = false;\r\n                        if (blackKing) {\r\n                            lastCheckmate = null;\r\n                            calcWhitePiecesSquare(whitePieces);\r\n                        }\r\n                        position.push(square);\r\n                        if (isBlack) {\r\n                            blackPieces.push({ i: parseInt(square.charAt(1)), j: columns.indexOf(square.charAt(0)) })\r\n                        }\r\n                        else {\r\n                            whitePieces.push({ i: parseInt(square.charAt(1)), j: columns.indexOf(square.charAt(0)) })\r\n                        }\r\n\r\n                        //if (color === 'w' && position.length > 1) {\r\n                        //if (index > 0 && index < indexOfBlack) {\r\n                        if (index === indexOfBlack) {\r\n                            // after all the white pieces have been placed\r\n                            whiteEmptyLines = emptyLines(whitePieces);\r\n                        }\r\n                        if (!whiteEmptyLines) {\r\n                            // TODO Implement this after the move: ignore if white has no check at the first move\r\n                            // do the job after all the pieces are placed\r\n                            if (pieces.length === 0) {\r\n                                blackEmptyLines = emptyLines(blackPieces);\r\n                                if (!blackEmptyLines) {\r\n                                    const fen = chess.fen();\r\n                                    const intersection = anyWhitePieceInsideOfBlackPiecesSquare(blackPieces);\r\n                                    if (!intersection) {\r\n                                        const response = { fen, firstMove: '' } as TProblem;\r\n                                        self.postMessage(JSON.stringify(response));\r\n                                        goToNextMoveOfTheLastWhitePiece = true;\r\n                                    }\r\n                                    else { \r\n                                        let firstMove = checkmateIn2();\r\n                                        const isCheckmate = firstMove !== null;\r\n                                        if (isCheckmate) {\r\n                                            if (firstMove === lastCheckmate ||\r\n                                                firstMove!.endsWith('=Q') || firstMove!.endsWith('=R')) {\r\n                                                firstMove = null;\r\n                                            }\r\n                                            else {\r\n                                                lastCheckmate = firstMove;\r\n                                                console.log('------', position, '---', fen);\r\n                                            }\r\n                                        }\r\n                                        const response = { fen, firstMove } as TProblem;\r\n                                        self.postMessage(JSON.stringify(response));\r\n                                        //if (isCheckmate) {\r\n                                        // if white move (Qf7) is checkmate, \r\n                                        // then ignore every problem, after all black pieces moves (except king), \r\n                                        // that produces checkmate (Qf7)\r\n                                        //}\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                getPosition([...pieces], index + 1);\r\n                            }\r\n                        }\r\n                        position.pop();\r\n                        if (isBlack) {\r\n                            blackPieces.pop()\r\n                        }\r\n                        else {\r\n                            whitePieces.pop()\r\n                        }\r\n                        const z = chess.remove(square);\r\n                        // const fen2 = chessPosition.fen();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (fromSquare === \"\") {\r\n        console.log('Invalid fromSquare')\r\n    }\r\n    else if (testFen) {\r\n        console.time()\r\n        const firstMove = checkmateIn2();\r\n        const response = {\r\n            fen: testFen,\r\n            firstMove\r\n        } as TProblem;\r\n        self.postMessage(JSON.stringify(response));\r\n        console.timeEnd()\r\n    }\r\n    else {\r\n        getPosition([...findProblem.pieces], 0);\r\n    }\r\n};\r\n\r\nexport { };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [777], function() { return __webpack_require__(505); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"0e9f84b3\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/chess-problem/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t505: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkchess_game\"] = self[\"webpackChunkchess_game\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(777).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["Board","columns","emptyLines","pieces","a","map","square","i","sort","x","length","j","iMinW","iMaxW","jMinW","jMaxW","calcWhitePiecesSquare","whitePieces","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","err","e","f","anyWhitePieceInsideOfBlackPiecesSquare","blackPieces","_step2","_iterator2","diagonal1","diagonal2","diagonal","_i","_arr","row","_loop","_arr2","_i2","_step3","_iterator3","_diagonal$square","line","includes","push","apply","_toConsumableArray","filter","_step4","_iterator4","_diagonal$square2","applyNightFirewall","board","queenOrBishop","squareQ","squareN","_ref","type","color","square2","jQ","parseInt","charAt","iQ","indexOf","jN","iN","bRet","Math","abs","arroundWhiteKing","arrounds","arr","r","c","touchingWhiteKing","whiteKingSquare","blackPieceSquare","Chess","require","regexCheck","RegExp","regexCheckmate","position","self","onmessage","findProblem","JSON","parse","data","action","indexOfBlack","lookingForFen","fromSquare","toSquare","testFen","whiteSquareBishops","chess","whiteBishops","squareColor","taken","_step7","_iterator7","piece","pieceColor","pieceType","toLowerCase","found","p","_ref3","isWhiteSquare","markWhiteSquareBishops","clear","nPatterns","applyQueenNightFirewall","applyBishopNightFirewall","applyRook","kingBoard","radi","_board2","isPattern","blackKingSquare","rooks","_ref2","iWK","jWK","iBK","jBK","_step5","_iterator5","rook","_step6","_iterator6","applyRookKing","checkmateIn2","moves1","moves","m","test","nMates1","firstMove","oneOfTheCheckmatesIsPattern","white1","move","blackMoves","nMates2","black","whiteMates","white2","undo","console","log","goToNextMoveOfTheLastWhitePiece","lastCheckmate","time","response","fen","postMessage","stringify","timeEnd","getPosition","index","shift","isBlack","whiteKing","blackKing","isBishop","whiteSquareBishop","boardMy","piecePlaced","put","invalidPos","assert","isAttacked","isCheck","remove","whiteEmptyLines","endsWith","pop","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next","then"],"sourceRoot":""}