{"version":3,"file":"static/js/777.0e9f84b3.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/chess.js/src/chess.ts","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport type Move = {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: string\n  san: string\n  lan: string\n  before: string\n  after: string\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string) {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]) {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string) {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string) {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n\n  constructor(fen = DEFAULT_POSITION) {\n    this.load(fen)\n  }\n\n  clear(keepHeaders = false) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = keepHeaders ? this._header : {}\n    this._updateSetup(this.fen())\n  }\n\n  removeHeader(key: string) {\n    if (key in this._header) {\n      delete this._header[key]\n    }\n  }\n\n  load(fen: string, keepHeaders = false) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    const { ok, error } = validateFen(fen)\n    if (!ok) {\n      throw new Error(error)\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear(keepHeaders)\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this.put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square)\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._updateSetup(this.fen())\n  }\n\n  fen() {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n      const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n      for (const square of squares) {\n        // is the square off the board?\n        if (square & 0x88) {\n          continue\n        }\n\n        const color = this._turn\n\n        // is there a pawn that can capture the epSquare?\n        if (\n          this._board[square]?.color === color &&\n          this._board[square]?.type === PAWN\n        ) {\n          // if the pawn makes an ep capture, does it leave it's king in check?\n          this._makeMove({\n            color,\n            from: square,\n            to: this._epSquare,\n            piece: PAWN,\n            captured: PAWN,\n            flags: BITS.EP_CAPTURE,\n          })\n          const isLegal = !this._isKingAttacked(color)\n          this._undoMove()\n\n          // if ep is legal, break and set the ep square in the FEN output\n          if (isLegal) {\n            epSquare = algebraic(this._epSquare)\n            break\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      delete this._header['SetUp']\n      delete this._header['FEN']\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square) {\n    return this._board[Ox88[square]] || false\n  }\n\n  put({ type, color }: { type: PieceSymbol; color: Color }, square: Square) {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    this._board[sq] = { type: type as PieceSymbol, color: color as Color }\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return true\n  }\n\n  remove(square: Square) {\n    const piece = this.get(square)\n    delete this._board[Ox88[square]]\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  _updateCastlingRights() {\n    const whiteKingInPlace = (this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE)\n    const blackKingInPlace = (this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK)\n\n    if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n  }\n\n  _updateEnPassantSquare() {\n    if(this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN;\n\n    if(!attackers.some(canCapture)) {\n      this._epSquare = EMPTY\n    }\n  }\n\n  _attacked(color: Color, square: number) {\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  private _isKingAttacked(color: Color) {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  isAttacked(square: Square, attackedBy: Color) {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck() {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck() {\n    return this.isCheck()\n  }\n\n  isCheckmate() {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate() {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial() {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isThreefoldRepetition() {\n    const moves = []\n    const positions: Record<string, number> = {}\n    let repetition = false\n\n    while (true) {\n      const move = this._undoMove()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /*\n       * remove the last two fields in the FEN string, they're not needed when\n       * checking for draw by rep\n       */\n      const fen = this.fen().split(' ').slice(0, 4).join(' ')\n\n      // has the position occurred three or move times\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      const move = moves.pop()\n\n      if (!move) {\n        break\n      } else {\n        this._makeMove(move)\n      }\n    }\n\n    return repetition\n  }\n\n  isDraw() {\n    return (\n      this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver() {\n    return this.isCheckmate() || this.isStalemate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => this._makePretty(move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}) {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {}\n  ) {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = this._makePretty(moveObj)\n\n    this._makeMove(moveObj)\n\n    return prettyMove\n  }\n\n  _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._board[move.to] = this._board[move.from]\n    delete this._board[move.from]\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        delete this._board[move.to - 16]\n      } else {\n        delete this._board[move.to + 16]\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._board[move.to] = { type: move.promotion, color: us }\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._board[castlingTo] = this._board[castlingFrom]\n        delete this._board[castlingFrom]\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      if (us === BLACK) {\n        this._epSquare = move.to - 16\n      } else {\n        this._epSquare = move.to + 16\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n  }\n\n  undo() {\n    const move = this._undoMove()\n    return move ? this._makePretty(move) : null\n  }\n\n  private _undoMove() {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._board[move.from] = this._board[move.to]\n    this._board[move.from].type = move.piece // to undo any promotions\n    delete this._board[move.to]\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._board[index] = { type: PAWN, color: them }\n      } else {\n        // regular capture\n        this._board[move.to] = { type: move.captured, color: them }\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n\n      this._board[castlingTo] = this._board[castlingFrom]\n      delete this._board[castlingFrom]\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}) {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       */\n      result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result?\n    if (typeof this._header.Result !== 'undefined') {\n      moves.push(this._header.Result)\n    }\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  header(...args: string[]) {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {}\n  ) {\n    function mask(str: string): string {\n      return str.replace(/\\\\/g, '\\\\')\n    }\n\n    function parsePgnHeader(header: string): { [key: string]: string } {\n      const headerObj: Record<string, string> = {}\n      const headers = header.split(new RegExp(mask(newlineChar)))\n      let key = ''\n      let value = ''\n\n      for (let i = 0; i < headers.length; i++) {\n        const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\n        key = headers[i].replace(regex, '$1')\n        value = headers[i].replace(regex, '$2')\n        if (key.trim().length > 0) {\n          headerObj[key] = value\n        }\n      }\n\n      return headerObj\n    }\n\n    // strip whitespace from head/tail of PGN block\n    pgn = pgn.trim()\n\n    /*\n     * RegExp to split header. Takes advantage of the fact that header and movetext\n     * will always have a blank line between them (ie, two newline_char's). Handles\n     * case where movetext is empty by matching newlineChar until end of string is\n     * matched - effectively trimming from the end extra newlineChar.\n     *\n     * With default newline_char, will equal:\n     * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n     */\n    const headerRegex = new RegExp(\n      '^(\\\\[((?:' +\n        mask(newlineChar) +\n        ')|.)*\\\\])' +\n        '((?:\\\\s*' +\n        mask(newlineChar) +\n        '){2}|(?:\\\\s*' +\n        mask(newlineChar) +\n        ')*$)'\n    )\n\n    // If no header given, begin with moves.\n    const headerRegexResults = headerRegex.exec(pgn)\n    const headerString = headerRegexResults\n      ? headerRegexResults.length >= 2\n        ? headerRegexResults[1]\n        : ''\n      : ''\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsePgnHeader(headerString)\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, true)\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag'\n          )\n        }\n        // second argument to load: don't clear the headers\n        this.load(headers['FEN'], true)\n      }\n    }\n\n    /*\n     * NB: the regexes below that delete move numbers, recursive annotations,\n     * and numeric annotation glyphs may also match text in comments. To\n     * prevent this, we transform comments by hex-encoding them in place and\n     * decoding them again after the other tokens have been deleted.\n     *\n     * While the spec states that PGN files should be ASCII encoded, we use\n     * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n     * for modern users\n     */\n\n    function toHex(s: string): string {\n      return Array.from(s)\n        .map(function (c) {\n          /*\n           * encodeURI doesn't transform most ASCII characters, so we handle\n           * these ourselves\n           */\n          return c.charCodeAt(0) < 128\n            ? c.charCodeAt(0).toString(16)\n            : encodeURIComponent(c).replace(/%/g, '').toLowerCase()\n        })\n        .join('')\n    }\n\n    function fromHex(s: string): string {\n      return s.length == 0\n        ? ''\n        : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'))\n    }\n\n    const encodeComment = function (s: string) {\n      s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ')\n      return `{${toHex(s.slice(1, s.length - 1))}}`\n    }\n\n    const decodeComment = function (s: string) {\n      if (s.startsWith('{') && s.endsWith('}')) {\n        return fromHex(s.slice(1, s.length - 1))\n      }\n    }\n\n    // delete header to get the moves\n    let ms = pgn\n      .replace(headerString, '')\n      .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'),\n        function (_match, bracket, semicolon) {\n          return bracket !== undefined\n            ? encodeComment(bracket)\n            : ' ' + encodeComment(`{${semicolon.slice(1)}}`)\n        }\n      )\n      .replace(new RegExp(mask(newlineChar), 'g'), ' ')\n\n    // delete recursive annotation variations\n    const ravRegex = /(\\([^()]+\\))+?/g\n    while (ravRegex.test(ms)) {\n      ms = ms.replace(ravRegex, '')\n    }\n\n    // delete move numbers\n    ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n    // delete ... indicating black to move\n    ms = ms.replace(/\\.\\.\\./g, '')\n\n    /* delete numeric annotation glyphs */\n    ms = ms.replace(/\\$\\d+/g, '')\n\n    // trim and get array of moves\n    let moves = ms.trim().split(new RegExp(/\\s+/))\n\n    // delete empty entries\n    moves = moves.filter((move) => move !== '')\n\n    let result = ''\n\n    for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n      const comment = decodeComment(moves[halfMove])\n      if (comment !== undefined) {\n        this._comments[this.fen()] = comment\n        continue\n      }\n\n      const move = this._moveFromSan(moves[halfMove], strict)\n\n      // invalid move\n      if (move == null) {\n        // was the move an end of game marker\n        if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n          result = moves[halfMove]\n        } else {\n          throw new Error(`Invalid move in PGN: ${moves[halfMove]}`)\n        }\n      } else {\n        // reset the end of game marker if making a valid move\n        result = ''\n        this._makeMove(move)\n      }\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    if (result && Object.keys(this._header).length && !this._header['Result']) {\n      this.header('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]) {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    const cleanMove = strippedSan(move)\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null;\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n          // if there is no from square, it could be just 'x' missing from a capture\n          if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n            return moves[i];\n          }\n      // hand-compare move properties with the results from our permissive regex\n      } else if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[from] == moves[i].from &&\n          Ox88[to] == moves[i].to &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii() {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number) {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  // pretty = external move object\n  private _makePretty(uglyMove: InternalMove): Move {\n    const { color, piece, from, to, flags, captured, promotion } = uglyMove\n\n    let prettyFlags = ''\n\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        prettyFlags += FLAGS[flag]\n      }\n    }\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    const move: Move = {\n      color,\n      piece,\n      from: fromAlgebraic,\n      to: toAlgebraic,\n      san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n      flags: prettyFlags,\n      lan: fromAlgebraic + toAlgebraic,\n      before: this.fen(),\n      after: '',\n    }\n\n    // generate the FEN for the 'after' key\n    this._makeMove(uglyMove)\n    move.after = this.fen()\n    this._undoMove()\n\n    if (captured) {\n      move.captured = captured\n    }\n    if (promotion) {\n      move.promotion = promotion\n      move.lan += promotion\n    }\n\n    return move\n  }\n\n  turn() {\n    return this._turn\n  }\n\n  board() {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square) {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(this._makePretty(move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment() {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  deleteComment() {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  deleteComments() {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(color: Color, rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>) {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n  }\n\n  getCastlingRights(color: Color) {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber() {\n    return this._moveNumber\n  }\n}\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toPropertyKey","arg","key","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_defineProperty","value","WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","DEFAULT_POSITION","EMPTY","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","SQUARES","BITS","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","PROMOTIONS","SIDES","_SIDES","ROOKS","square","flag","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","indexOf","algebraic","f","substring","swapColor","color","validateFen","fen","tokens","split","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","sumFields","previousWasNumber","_i","_kings","regex","_kings$_i","concat","match","addMove","moves","from","to","piece","captured","arguments","flags","push","promotion","inferPieceType","san","pieceType","charAt","toLowerCase","strippedSan","move","replace","Chess","instance","Constructor","_classCallCheck","Array","this","load","protoProps","staticProps","keepHeaders","_board","_turn","_castling","_epSquare","_halfMoves","_moveNumber","_history","_comments","_header","_updateSetup","slice","join","_validateFen","Error","position","clear","put","type","empty","_this$_board$i","toUpperCase","castling","epSquare","bigPawnSquare","_i2","_squares","_this$_board$square","_this$_board$square2","_makeMove","isLegal","_isKingAttacked","_undoMove","_ref","sq","_updateCastlingRights","_updateEnPassantSquare","get","_this$_board$Ox88$e","_this$_board$Ox88$e2","_this$_board$Ox88$e3","_this$_board$Ox88$e4","_this$_board$Ox88$a","_this$_board$Ox88$a2","_this$_board$Ox88$h","_this$_board$Ox88$h2","_this$_board$Ox88$a3","_this$_board$Ox88$a4","_this$_board$Ox88$h3","_this$_board$Ox88$h4","whiteKingInPlace","blackKingInPlace","_this$_board$currentS","_this$_board$currentS2","_this","startSquare","currentSquare","attackers","some","_this$_board$square3","_this$_board$square4","difference","index","offset","j","blocked","_attacked","attackedBy","isCheck","_moves","pieces","bishops","numPieces","squareColor","sum","len","positions","repetition","pop","isStalemate","isInsufficientMaterial","isThreefoldRepetition","isCheckmate","isDraw","_this2","_ref2","_ref2$verbose","verbose","_ref2$square","_ref2$piece","map","_makePretty","_moveToSan","_ref3","_ref3$legal","legal","_ref3$piece","_ref3$square","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","_this$_board$to","castlingFrom","castlingTo","legalMoves","_ref4$strict","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","kings","turn","_push","old","_this3","_ref5","_ref5$newline","newline","_ref5$maxWidth","maxWidth","result","headerExists","appendComment","moveString","comment","delimiter","reversedHistory","prefix","Result","strip","wrapComment","width","_step","_iterator","_createForOfIteratorHelper","s","done","token","err","e","currentWidth","includes","_len3","args","_key","pgn","_ref6","_ref6$strict","_ref6$newlineChar","newlineChar","mask","str","trim","headerRegexResults","RegExp","exec","headerString","reset","headers","header","headerObj","parsePgnHeader","encodeComment","charCodeAt","toString","encodeURIComponent","toHex","decodeComment","startsWith","endsWith","decodeURIComponent","fromHex","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","keys","output","disambiguator","ambiguities","sameRank","sameFile","ambigFrom","ambigTo","getDisambiguator","cleanMove","matches","overlyDisambiguated","depth","nodes","perft","uglyMove","prettyFlags","fromAlgebraic","toAlgebraic","lan","before","after","row","_ref7$verbose","moveHistory","_this4","currentComments","copyComment","_this5","_pruneComments","_this6","rights","_i7","_arr","side","getCastlingRights","_ref8","_arrayLikeToArray","arr","arr2","_arrayWithoutHoles","isArray","o","allowArrayLike","it","F","_e","normalCompletion","didErr","step","next","_e2","_iterableToArray","iter","_nonIterableSpread","_toConsumableArray","_unsupportedIterableToArray","minLen","name"],"sourceRoot":""}